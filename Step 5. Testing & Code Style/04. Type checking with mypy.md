Below is a **clean, structured, beginner-friendly explanation** of **type checking with mypy**, with no star icons in headings.

---

# What Is mypy?

`mypy` is a **static type checker** for Python.

It examines your code **before running it** and finds:

* Type mismatches
* Improper function usage
* Wrong return types
* Incorrect variable assignments
* Missing attributes
* Errors that would otherwise appear only at runtime

Using `mypy` makes your code safer, more predictable, and easier to maintain — especially in large FastAPI or backend projects.

---

# Why Use mypy?

Python is dynamically typed, so these bugs won’t raise errors:

```python
age: int = "hello"  # no runtime error → but wrong
```

mypy will detect it:

```
error: Incompatible types in assignment (expression has type "str", variable has type "int")
```

Benefits:

* Catches bugs early
* Improves code readability
* Works with modern type hints
* Helps IDEs provide better autocomplete
* Essential for large production codebases

---

# Installing mypy

With pip:

```
pip install mypy
```

With Poetry:

```
poetry add --dev mypy
```

---

# Running mypy

Check the entire project:

```
mypy .
```

Check a specific file:

```
mypy app/services/user_service.py
```

---

# Type Hints mypy Understands

mypy supports all modern Python typing features:

* `str`, `int`, `float`, `bool`
* `list[str]`, `dict[str, int]`, `tuple[int, ...]`
* `set[int]`
* `Optional[str]` or `str | None`
* `TypedDict`
* `Enum`
* `Literal`
* `Union`
* `Protocol`
* `Callable`
* `Annotated`

And much more.

---

# Basic Examples

### Function type hints

```python
def add(a: int, b: int) -> int:
    return a + b
```

mypy error:

```python
add("1", 2)  # error: Argument 1 to "add" has incompatible type "str"
```

### Variable type hints

```python
name: str = "Nitin"
age: int = 25
```

mypy will warn if you assign the wrong type.

---

# Optional and Union Types

```python
from typing import Optional

def get_user(id: int) -> Optional[str]:
    if id == 1:
        return "Nitin"
    return None
```

or modern syntax:

```python
def get_user(id: int) -> str | None:
    ...
```

---

# Typed Lists and Dicts

```python
users: list[str] = ["A", "B"]
config: dict[str, int] = {"port": 8000}
```

mypy will detect if you push the wrong type:

```python
users.append(123)  # error
```

---

# Classes With Type Hints

```python
class User:
    id: int
    name: str

    def __init__(self, id: int, name: str):
        self.id = id
        self.name = name
```

mypy checks:

```python
u = User("abc", 123)  # both are errors
```

---

# Using TypedDict for JSON-like Data

```python
from typing import TypedDict

class UserDict(TypedDict):
    id: int
    name: str

def process_user(data: UserDict):
    print(data["id"])
```

---

# Type Checking Async Functions

```python
from typing import Awaitable

async def fetch_data() -> int:
    return 10

async def main() -> None:
    value: int = await fetch_data()
```

mypy warns if you forget to `await`.

---

# Configuring mypy (Recommended)

Create `mypy.ini` or put this in `setup.cfg`:

```ini
[mypy]
python_version = 3.12
ignore_missing_imports = true
strict = false
warn_unused_ignores = true
warn_return_any = true
warn_unused_configs = true
```

### `ignore_missing_imports = true`

Avoids errors when libraries don't have type stubs.

### Strict mode (optional but recommended for real projects)

```ini
strict = true
```

This enables:

* `disallow_untyped_defs`
* `disallow_any_generics`
* `no_implicit_optional`
* `warn_unused_ignores`

Using strict mode forces better discipline.

---

# Using mypy With VS Code

pylance automatically shows mypy-like warnings,
but you can also enable real mypy:

Install extension: **mypy (Microsoft)**
or configure tasks:

```json
{
  "python.linting.mypyEnabled": true
}
```

---

# Running mypy in CI/CD

GitHub Actions example:

```yaml
- name: Run mypy
  run: mypy .
```

CI will fail if type errors exist.

---

# mypy With FastAPI

FastAPI encourages type hints, so mypy integrates well.

Example handler:

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class UserIn(BaseModel):
    name: str
    age: int

class UserOut(BaseModel):
    id: int
    name: str
    age: int

@app.post("/users", response_model=UserOut)
async def create_user(user: UserIn) -> UserOut:
    return UserOut(id=1, name=user.name, age=user.age)
```

mypy checks:

* Request model correctness
* Response model correctness
* Return types
* Async type correctness

---

# mypy With SQLAlchemy

Type checking with SQLAlchemy is tricky, but works well with:

```
pip install sqlalchemy2-stubs
```

Your IDE and mypy will then understand ORM models.

---

# mypy With pre-commit (Highly Recommended)

Add this to `.pre-commit-config.yaml`:

```yaml
repos:
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.10.0
    hooks:
      - id: mypy
```

Now mypy runs automatically before each git commit.

---

# Summary

mypy helps you:

* Catch type bugs early
* Improve code robustness
* Document code better
* Write safer APIs
* Improve IDE autocomplete
* Build better FastAPI backend services

In a modern Python project (FastAPI, SQLAlchemy, Pydantic, async APIs), mypy is extremely important.

---
