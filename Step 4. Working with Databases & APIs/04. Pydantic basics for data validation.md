Here is a **very clear, practical, beginner-friendly guide** to **Pydantic basics for data validation**.
You *must* understand this before building FastAPI APIs because **Pydantic is the heart of FastAPI request/response validation**.

We will cover:

* What is Pydantic
* Models
* Fields & types
* Validation
* Required vs optional
* Default values
* Nested models
* Validators
* Error messages
* Examples for FastAPI

This is meant for beginners — clean and easy to understand.

---

# ⭐ 1. What is Pydantic?

Pydantic is a Python library that:

* Validates data
* Ensures correct types
* Converts (parses) data into correct types
* Prevents invalid API input
* Serializes and structures data

Pydantic is used heavily in FastAPI for request/response models.

---

# ⭐ 2. Basic Pydantic Model

A Pydantic model is a Python class that inherits from `BaseModel`.

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str
```

This defines a **schema** — rules for valid data.

---

# ⭐ 3. Creating an object

```python
u = User(id=1, name="Nitin", email="test@example.com")
print(u)
```

Pydantic automatically parses and validates everything.

---

# ⭐ 4. Automatic Type Conversion

Pydantic tries to convert inputs into correct types:

```python
User(id="1", name="Nitin", email="test@example.com")
```

`id="1"` (string) ➝ **converted to integer**

---

# ⭐ 5. Validation error

Invalid data:

```python
User(id="abc", name=123, email="not-email")
```

Result:

```
pydantic.error_wrappers.ValidationError
```

Pydantic gives **very detailed** error messages.

---

# ⭐ 6. Required vs Optional Fields

### Required (must be provided):

```python
name: str
```

### Optional (can be None):

```python
from typing import Optional

name: Optional[str] = None
```

or modern Python syntax:

```python
name: str | None = None
```

---

# ⭐ 7. Default Values

```python
class User(BaseModel):
    id: int
    name: str = "Guest"
```

`name` defaults to `"Guest"` if not provided.

---

# ⭐ 8. Nested Models

You can place one model inside another.

```python
class Address(BaseModel):
    city: str
    country: str

class User(BaseModel):
    name: str
    address: Address
```

Use:

```python
u = User(
    name="Nitin",
    address={"city": "Mumbai", "country": "India"}
)
```

Pydantic automatically converts `dict` → `Address` object.

---

# ⭐ 9. Lists, Dicts, Sets (typed)

```python
class Tags(BaseModel):
    tags: list[str]
```

```python
class Config(BaseModel):
    settings: dict[str, int]
```

```python
class Numbers(BaseModel):
    values: set[int]
```

---

# ⭐ 10. Field validation (min, max, regex, length, etc.)

Using `Field()`:

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    username: str = Field(min_length=3, max_length=20)
    age: int = Field(gt=0, lt=120)  # greater than 0, less than 120
```

Examples:

* `min_length`
* `max_length`
* `gt` (greater than)
* `lt` (less than)
* `regex`

---

# ⭐ 11. Custom Validators

Use `field_validator` (Pydantic v2).

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    email: str

    @field_validator("email")
    def check_email(cls, value):
        if "@" not in value:
            raise ValueError("Invalid email format")
        return value
```

Usage:

```python
User(email="test@example.com")  # valid
User(email="invalid")           # raises error
```

---

# ⭐ 12. Model Methods (Pydantic v2)

### Convert to dict:

```python
u = User(id=1, name="Nitin")
print(u.model_dump())
```

### Convert to JSON:

```python
print(u.model_dump_json())
```

---

# ⭐ 13. Using Pydantic with FastAPI (important!)

### Request Body Model:

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class CreateUser(BaseModel):
    name: str
    email: str

@app.post("/users")
async def create_user(data: CreateUser):
    return data
```

FastAPI will:

* Validate the incoming JSON
* Reject invalid input
* Convert JSON ➝ Python model

Example input:

```json
{
  "name": "Nitin",
  "email": "nitin@example.com"
}
```

---

# ⭐ 14. Response Models (output validation)

```python
@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: int):
    return User(id=user_id, name="Nitin", email="test@example.com")
```

FastAPI ensures:

* only allowed fields go out
* data is validated before returning

---

# ⭐ 15. Required, Optional, Defaults Summary

| Example                 | Meaning                 |                       |
| ----------------------- | ----------------------- | --------------------- |
| `name: str`             | required                |                       |
| `name: str = "default"` | optional, default value |                       |
| `name: str              | None = None`            | optional, can be None |

---

# ⭐ 16. Common Patterns You Will Use Daily

### ✔ Pydantic for request models

### ✔ Pydantic for response models

### ✔ Pydantic for DB → API serialization

### ✔ Pydantic for environment variables

### ✔ Pydantic for config objects

### ✔ Pydantic for validation in services

Pydantic is *everywhere* in modern Python.

---

# ⭐ 17. Full Real Example (CRUD Model)

```python
class UserCreate(BaseModel):
    name: str
    email: str

class UserRead(BaseModel):
    id: int
    name: str
    email: str
```

Usage:

```python
@app.post("/users", response_model=UserRead)
async def create_user(data: UserCreate):
    user = save_to_db(data)
    return user
```

---

# ⭐ Summary

| Feature                   | Supported by Pydantic? |
| ------------------------- | ---------------------- |
| Automatic type conversion | ✔                      |
| JSON validation           | ✔                      |
| Nested structures         | ✔                      |
| Custom validators         | ✔                      |
| Optional/required fields  | ✔                      |
| Regex validation          | ✔                      |
| Serialization (dict/json) | ✔                      |
| FastAPI integration       | ✔✔✔ (core feature)     |

---
