Here is a **clean, beginner-friendly, and deep explanation** of **Python decorators**, written in a way that a new Python developer (coming from PHP/JavaScript background) can understand them easily.

Decorators power many advanced features in Python ‚Äî including **FastAPI dependencies, middleware, rate-limiting, logging, caching**, and more. Understanding them is essential.

---

# ‚≠ê **Decorators in Python ‚Äî A Complete, Simple Explanation**

## üîπ What is a decorator?

A **decorator** is a function that **wraps another function** to:

* modify its behavior
* add extra features
* run custom logic before/after it runs

Without changing the original function‚Äôs code.

This is extremely powerful.

---

# üîπ Analogy (Simple)

Imagine you have a function:

```
make_coffee()
```

You want to:

* log time
* check authentication
* handle errors
* measure performance

But you don‚Äôt want to rewrite this logic inside every function.

Instead you create:

```
@logger
@authenticate
@measure_time
def make_coffee():
    ...
```

Each decorator adds extra behavior.

---

# ‚≠ê **1. Functions Are First-Class in Python**

This is important:
**You can pass functions as arguments and return functions.**

Example:

```python
def greet():
    return "Hello!"

def call_function(f):
    print(f())

call_function(greet)
```

Functions behave like data ‚Äî decorators use this power.

---

# ‚≠ê **2. Basic Decorator Structure**

A decorator is a function that:

* takes a function as input
* returns another function

Example:

```python
def my_decorator(fn):
    def wrapper():
        print("Before function runs")
        fn()
        print("After function runs")
    return wrapper
```

Use it like:

```python
@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

Output:

```
Before function runs
Hello!
After function runs
```

---

# ‚≠ê **3. How decorators work internally**

This:

```python
@my_decorator
def say_hi():
    print("Hi")
```

Is the same as:

```python
def say_hi():
    print("Hi")

say_hi = my_decorator(say_hi)
```

The decorator **returns a new function** that replaces the old one.

---

# ‚≠ê **4. Decorators with Arguments**

Many real-life decorators need arguments (like rate-limiting, retry counts, cache time, etc.)

Example:

```python
def repeat(n):
    def decorator(fn):
        def wrapper():
            for _ in range(n):
                fn()
        return wrapper
    return decorator
```

Usage:

```python
@repeat(3)
def hello():
    print("Hello")

hello()
```

Output:

```
Hello
Hello
Hello
```

Explanation:
`repeat(3)` returns a decorator ‚Üí decorator wraps function ‚Üí new function executed 3 times.

---

# ‚≠ê **5. Decorators on Functions with Arguments**

To support any parameters:

```python
def logger(fn):
    def wrapper(*args, **kwargs):
        print("Arguments:", args, kwargs)
        return fn(*args, **kwargs)
    return wrapper
```

Usage:

```python
@logger
def add(a, b):
    return a + b

print(add(5, 10))
```

Output:

```
Arguments: (5, 10) {}
15
```

`*args` ‚Üí tuple of positional arguments
`**kwargs` ‚Üí dictionary of keyword arguments

---

# ‚≠ê **6. Using `functools.wraps` (Important)**

Without `wraps`, decorated functions lose:

* name
* docstring
* metadata
* FastAPI compatibility

Correct:

```python
from functools import wraps

def logger(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        print("running", fn.__name__)
        return fn(*args, **kwargs)
    return wrapper
```

---

# ‚≠ê **7. Multiple Decorators Stacked**

The top decorator runs **last**.

```python
@d1
@d2
def fn():
    ...
```

Equivalent to:

```
fn = d1(d2(fn))
```

---

# ‚≠ê **8. Class-Based Decorators**

A class can also be used as a decorator.

```python
class Decorator:
    def __init__(self, fn):
        self.fn = fn

    def __call__(self):
        print("Before")
        self.fn()
        print("After")

@Decorator
def hello():
    print("Hello")
```

---

# üéØ **9. Real-World Examples**

## ‚úî **Example 1: Logging Decorator**

```python
from functools import wraps

def log(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        print(f"Running: {fn.__name__}")
        return fn(*args, **kwargs)
    return wrapper
```

---

## ‚úî **Example 2: Authentication Decorator**

```python
def require_login(fn):
    @wraps(fn)
    def wrapper(user, *args, **kwargs):
        if not user.get("logged_in"):
            return "Access denied"
        return fn(user, *args, **kwargs)
    return wrapper
```

---

## ‚úî **Example 3: Execution Time (Performance)**

```python
import time

def time_it(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = fn(*args, **kwargs)
        end = time.time()
        print(f"Took {end - start:.4f} seconds")
        return result
    return wrapper
```

---

## ‚úî **Example 4: Retry Failed Functions**

```python
def retry(n):
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            for attempt in range(n):
                try:
                    return fn(*args, **kwargs)
                except Exception:
                    print(f"Retrying {attempt+1}/{n}")
            raise Exception("Failed after retries")
        return wrapper
    return decorator
```

---

# üéØ **10. Decorators in FastAPI (VERY Important)**

FastAPI uses decorators for:

### ‚úî Route handling

```python
@app.get("/users")
def list_users():
    return []
```

### ‚úî Middleware

```python
@app.middleware("http")
async def add_header(request, call_next):
    response = await call_next(request)
    return response
```

### ‚úî Dependencies

```python
def get_db():
    ...

@app.get("/items")
def get_items(db = Depends(get_db)):
    return []
```

Dependencies are **decorators behind the scenes**.

---

# üéØ **11. Summary Table**

| Concept             | Meaning                                                |
| ------------------- | ------------------------------------------------------ |
| Decorator           | Function that wraps/enhances another function          |
| `@decorator`        | Sugar for `fn = decorator(fn)`                         |
| Wrapper             | The modified function returned by decorator            |
| `*args`, `**kwargs` | Allow dynamic parameters                               |
| `@wraps`            | Preserves original metadata                            |
| Arguments           | Decorators can accept arguments using nested functions |

---
